{"version":3,"file":"sifter.min.js","sources":["../../lib/diacritics.ts","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["\ntype TDiacraticList = {[key:string]:string};\n\n// https://github.com/andrewrk/node-diacritics/blob/master/index.js\n\nvar latin_pat:RegExp;\nconst accent_pat = '[\\u0300-\\u036F\\u{b7}\\u{2be}]'; // \\u{2bc}\nconst accent_reg = new RegExp(accent_pat,'g');\nvar diacritic_patterns:TDiacraticList;\n\nconst latin_convert:TDiacraticList = {\n\t'æ': 'ae',\n\t'ⱥ': 'a',\n\t'ø': 'o',\n};\n\nconst convert_pat = new RegExp(Object.keys(latin_convert).join('|'),'g');\n\n\nexport const DIACRITICS:TDiacraticList = {\n\t\" \":\" \",\n\t0:\"߀\",\n\tA:\"ⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ\",\n\tAA:\"Ꜳ\",\n\tAE:\"ÆǼǢ\",\n\tAO:\"Ꜵ\",\n\tAU:\"Ꜷ\",\n\tAV:\"ꜸꜺ\",\n\tAY:\"Ꜽ\",\n\tB:\"ⒷＢḂḄḆɃƁ\",\n\tC:\"ⒸＣꜾḈĆCĈĊČÇƇȻ\",\n\tD:\"ⒹＤḊĎḌḐḒḎĐƊƉᴅꝹ\",\n\tDh:\"Ð\",\n\tDZ:\"ǱǄ\",\n\tDz:\"ǲǅ\",\n\tE:\"ɛⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎᴇ\",\n\tF:\"ꝼⒻＦḞƑꝻ\",\n\tG:\"ⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾɢ\",\n\tH:\"ⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ\",\n\tI:\"ⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ\",\n\tJ:\"ⒿＪĴɈȷ\",\n\tK:\"ⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ\",\n\tL:\"ⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ\",\n\tLJ:\"Ǉ\",\n\tLj:\"ǈ\",\n\tM:\"ⓂＭḾṀṂⱮƜϻ\",\n\tN:\"ꞤȠⓃＮǸŃÑṄŇṆŅṊṈƝꞐᴎ\",\n\tNJ:\"Ǌ\",\n\tNj:\"ǋ\",\n\tO:\"ⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ\",\n\tOE:\"Œ\",\n\tOI:\"Ƣ\",\n\tOO:\"Ꝏ\",\n\tOU:\"Ȣ\",\n\tP:\"ⓅＰṔṖƤⱣꝐꝒꝔ\",\n\tQ:\"ⓆＱꝖꝘɊ\",\n\tR:\"ⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ\",\n\tS:\"ⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ\",\n\tT:\"ⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ\",\n\tTh:\"Þ\",\n\tTZ:\"Ꜩ\",\n\tU:\"ⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ\",\n\tV:\"ⓋＶṼṾƲꝞɅ\",\n\tVY:\"Ꝡ\",\n\tW:\"ⓌＷẀẂŴẆẄẈⱲ\",\n\tX:\"ⓍＸẊẌ\",\n\tY:\"ⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ\",\n\tZ:\"ⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ\",\n\ta:\"ⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑ\",\n\taa:\"ꜳ\",\n\tae:\"æǽǣ\",\n\tao:\"ꜵ\",\n\tau:\"ꜷ\",\n\tav:\"ꜹꜻ\",\n\tay:\"ꜽ\",\n\tb:\"ⓑｂḃḅḇƀƃɓƂ\",\n\tc:\"ｃⓒćĉċčçḉƈȼꜿↄ\",\n\td:\"ⓓｄḋďḍḑḓḏđƌɖɗƋᏧԁꞪ\",\n\tdh:\"ð\",\n\tdz:\"ǳǆ\",\n\te:\"ⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇǝ\",\n\tf:\"ⓕｆḟƒ\",\n\tff:\"ﬀ\",\n\tfi:\"ﬁ\",\n\tfl:\"ﬂ\",\n\tffi:\"ﬃ\",\n\tffl:\"ﬄ\",\n\tg:\"ⓖｇǵĝḡğġǧģǥɠꞡꝿᵹ\",\n\th:\"ⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ\",\n\thv:\"ƕ\",\n\ti:\"ⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı\",\n\tj:\"ⓙｊĵǰɉ\",\n\tk:\"ⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ\",\n\tl:\"ⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇɭ\",\n\tlj:\"ǉ\",\n\tm:\"ⓜｍḿṁṃɱɯ\",\n\tn:\"ⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥлԉ\",\n\tnj:\"ǌ\",\n\to:\"ⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿꝋꝍɵɔᴑ\",\n\toe:\"œ\",\n\toi:\"ƣ\",\n\too:\"ꝏ\",\n\tou:\"ȣ\",\n\tp:\"ⓟｐṕṗƥᵽꝑꝓꝕρ\",\n\tq:\"ⓠｑɋꝗꝙ\",\n\tr:\"ⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ\",\n\ts:\"ⓢｓśṥŝṡšṧṣṩșşȿꞩꞅẛʂ\",\n\tss:\"ß\",\n\tt:\"ⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ\",\n\tth:\"þ\",\n\ttz:\"ꜩ\",\n\tu:\"ⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ\",\n\tv:\"ⓥｖṽṿʋꝟʌ\",\n\tvy:\"ꝡ\",\n\tw:\"ⓦｗẁẃŵẇẅẘẉⱳ\",\n\tx:\"ⓧｘẋẍ\",\n\ty:\"ⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ\",\n\tz:\"ⓩｚźẑżžẓẕƶȥɀⱬꝣ\"\n}\n\n/**\n * code points generated from toCodePoints();\n * removed 65339 to 65345\n */\nexport const code_points = [\n\t[ 67, 67 ],\n\t[ 160, 160 ],\n\t[ 192, 438 ],\n\t[ 452, 652 ],\n\t[ 961, 961 ],\n\t[ 1019, 1019 ],\n\t[ 1083, 1083 ],\n\t[ 1281, 1289 ],\n\t[ 1984, 1984 ],\n\t[ 5095, 5095 ],\n\t[ 7429, 7441 ],\n\t[ 7545, 7549 ],\n\t[ 7680, 7935 ],\n\t[ 8580, 8580 ],\n\t[ 9398, 9449 ],\n\t[ 11360, 11391 ],\n\t[ 42792, 42793 ],\n\t[ 42802, 42851 ],\n\t[ 42873, 42897 ],\n\t[ 42912, 42922 ],\n\t[ 64256, 64260 ],\n\t[ 65313, 65338 ],\n\t[ 65345, 65370 ]\n];\n\n/**\n * Remove accents\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n *\n */\nexport const asciifold = (str:string):string => {\n\treturn str\n\t\t.normalize('NFKD')\n\t\t.replace(accent_reg, '')\n\t\t.toLowerCase()\n\t\t.replace(convert_pat,function(foreignletter) {\n\t\t\treturn latin_convert[foreignletter];\n\t\t});\n};\n\n\n/**\n * Convert list of diacritics to array of code points\n *\n */\n// @ts-ignore\nfunction toCodePoints(tolerance=8){\n\tvar char_codes:number[] = [];\n\n\tfor( let letter in DIACRITICS ){\n\t\tlet _diacritics = DIACRITICS[letter];\n\t\tfor( let n = 0; n < _diacritics.length; n++ ){\n\t\t\tvar code_point = _diacritics.codePointAt(n);\n\t\t\tif( code_point ) char_codes.push( code_point );\n\t\t}\n\t}\n\n\t//https://stackoverflow.com/questions/40431572/is-there-a-simple-way-to-group-js-array-values-by-range\n\tchar_codes.sort((a, b) => a - b);\n\tvar accumulator: number[][] = [];\n\tchar_codes.reduce(function (accumulator, currentValue, index, source) {\n\n\t\tif( !index ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else if( currentValue - source[index - 1] > tolerance ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else{\n\n\t\t\tlet range = accumulator.pop();\n\t\t\tif( range ){\n\t\t\t\taccumulator.push( [range[0],currentValue]);\n\t\t\t}\n\t\t}\n\n\t\treturn accumulator;\n\t}, accumulator);\n\n}\n\n/**\n * Convert array of strings to a regular expression\n *\tex ['ab','a'] => (?:ab|a)\n *\n */\nexport const arrayToPattern = (chars:string[],glue:string='|'):string =>{\n\tif( chars.length > 1 ){\n\t\treturn '(?:'+chars.join(glue)+')';\n\t}\n\treturn chars[0];\n};\n\n/**\n * Get all possible combinations of substrings that add up to the given string\n * https://stackoverflow.com/questions/30169587/find-all-the-combination-of-substrings-that-add-up-to-the-given-string\n *\n */\nexport const allSubstrings = (input:string):string[][] => {\n\n    if( input.length === 1) return [[input]];\n\n    var result:string[][] = [];\n    allSubstrings(input.substring(1)).forEach(function(subresult) {\n        var tmp = subresult.slice(0);\n        tmp[0] = input.charAt(0) + tmp[0];\n        result.push(tmp);\n\n        tmp = subresult.slice(0);\n        tmp.unshift(input.charAt(0));\n        result.push(tmp);\n    });\n    \n    return result;\n}\n\n/**\n * Generate a list of diacritics from the list of code points\n *\n */\nexport const generateDiacritics = ():TDiacraticList => {\t\n\n\tvar diacritics:{[key:string]:string[]} = {};\n\tcode_points.forEach((code_range)=>{\n\n\t\tfor(let i = code_range[0]; i <= code_range[1]; i++){\n\t\t\t\n\t\t\tlet diacritic\t= String.fromCharCode(i);\t\t\t\n\t\t\tlet\tlatin\t\t= asciifold(diacritic);\t\t\t\n\t\t\t\t\n\t\t\tif( latin == diacritic.toLowerCase() ){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif( !(latin in diacritics) ){\n\t\t\t\tdiacritics[latin] = [latin];\n\t\t\t}\n\t\t\tdiacritics[latin].push(diacritic);\n\t\t}\n\t});\n\t\t\n\tvar latin_chars = Object.keys(diacritics);\n\t\n\t\n\t// latin character pattern\n\t// match longer substrings first\n\tlatin_chars\t\t= latin_chars.sort((a, b) => b.length - a.length );\n\tlatin_pat\t\t= new RegExp('('+ arrayToPattern(latin_chars) + accent_pat + '*)','g');\n\t\n\t\n\t// build diacritic patterns\n\t// ae needs: \n\t//\t(?:(?:ae|Æ|Ǽ|Ǣ)|(?:A|Ⓐ|Ａ...)(?:E|ɛ|Ⓔ...))\n\tvar diacritic_patterns:TDiacraticList = {};\n\tlatin_chars.sort((a,b) => a.length -b.length).forEach((latin)=>{\n\t\t\n\t\tvar substrings\t= allSubstrings(latin);\n\t\tvar pattern = substrings.map((sub_pat)=>{\n\t\t\t\n\t\t\tsub_pat = sub_pat.map((l)=>{\n\t\t\t\tif( diacritics.hasOwnProperty(l) ){\n\t\t\t\t\treturn arrayToPattern(diacritics[l]);\n\t\t\t\t}\n\t\t\t\treturn l;\n\t\t\t});\n\t\t\t\n\t\t\treturn arrayToPattern(sub_pat,'');\n\t\t});\n\t\t\n\t\tdiacritic_patterns[latin] = arrayToPattern(pattern);\t\t\n\t});\n\t\t\t\n\treturn diacritic_patterns;\n}\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n */\nexport const diacriticRegexPoints = (regex:string):string => {\n\n\tif( diacritic_patterns === undefined ){\n\t\tdiacritic_patterns = generateDiacritics();\n\t}\n\t\n\tconst decomposed\t\t= regex.normalize('NFKD').toLowerCase();\n\t\n\treturn decomposed.split(latin_pat).map((part:string)=>{\n\t\t\n\t\tif( part == '' ){\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\t// \"ﬄ\" or \"ffl\"\n\t\tconst no_accent = asciifold(part);\t\t\t\t\n\t\tif( diacritic_patterns.hasOwnProperty(no_accent) ){\n\t\t\treturn diacritic_patterns[no_accent];\n\t\t}\n\t\t\n\t\t// 'أهلا' (\\u{623}\\u{647}\\u{644}\\u{627}) or 'أهلا' (\\u{627}\\u{654}\\u{647}\\u{644}\\u{627})\n\t\tconst composed_part = part.normalize('NFC');\n\t\tif( composed_part != part ){\n\t\t\treturn arrayToPattern([part,composed_part]);\n\t\t}\n\t\t\t\t\n\t\treturn part;\n\t}).join('');\n\t\n}\n","\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { asciifold } from './diacritics.ts';\n\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from './types.ts';\n\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttr = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport const getAttrNesting = (obj:{[key:string]:any}, name:string ) => {\n    if (!obj ) return;\n    var part, names = name.split(\".\");\n\twhile( (part = names.shift()) && (obj = obj[part]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n */\nexport const scoreValue = (value:string, token:T.Token, weight:number ):number => {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\n/**\n *\n * https://stackoverflow.com/questions/63006601/why-does-u-throw-an-invalid-escape-error\n */\nexport const escape_regex = (str:string):string => {\t\n\treturn (str + '').replace(/([\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\|\\}\\\\])/gu, '\\\\$1');\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport const propToArray = (obj:{[key:string]:any}, key:string) => {\n\tvar value = obj[key];\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n */\nexport const iterate = (object:[]|{[key:string]:any}, callback:(value:any,key:number|string)=>any) => {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport const cmp = (a:number|string, b:number|string) => {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\n // @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { scoreValue, getAttr, getAttrNesting, escape_regex, propToArray, iterate, cmp } from './utils.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport { diacriticRegexPoints } from './diacritics.ts';\n// @ts-ignore TS2691 \"An import path cannot end with a '.ts' extension\"\nimport * as T from 'types.ts';\n\nexport default class Sifter{\n\n\tpublic items; // []|{};\n\tpublic settings: T.Settings;\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t */\n\tconstructor(items:any, settings:T.Settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:T.Weights ):T.Token[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens:T.Token[]\t= [];\n\t\tconst words\t\t\t\t= query.split(/\\s+/);\n\t\tvar field_regex:RegExp;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field:null|string\t= null;\n\t\t\tlet regex:null|string\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1];\n\t\t\t\tword\t= field_match[2];\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tregex = escape_regex(word);\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = diacriticRegexPoints(regex);\n\t\t\t\t}\n\t\t\t\tif( respect_word_boundaries ) regex = \"\\\\b\"+regex;\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex ? new RegExp(regex,'iu') : null,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {function}\n\t */\n\tgetScoreFunction(query:string, options:T.Options ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t_getScoreFunction(search:T.PrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\t\tconst field = fields[0].field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:T.Token, data:{}) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight:number, field:string) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data:{}) {\n\t\t\t\treturn scoreObject(tokens[0], data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar i = 0, score, sum = 0;\n\t\t\t\tfor (; i < token_count; i++) {\n\t\t\t\t\tscore = scoreObject(tokens[i], data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data:{}) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:T.Token)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options:T.Options) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:T.PrepareObj){\n\t\tvar i, n, implicit_score;\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) ? options.sort_empty : options.sort,\n\t\tsort_flds:T.Sort[]\t\t= [],\n\t\tmultipliers:number[]\t= [];\n\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t */\n\t\tconst get_field = function(name:string, result:T.ResultItem):string|number {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor (i = 0, n = sort.length; i < n; i++) {\n\t\t\t\tif (search.query || sort[i].field !== '$score') {\n\t\t\t\t\tsort_flds.push(sort[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\tsort_flds.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\tmultipliers.push(sort_flds[i].direction === 'desc' ? -1 : 1);\n\t\t}\n\n\t\t// build function\n\t\tconst sort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t} else if (sort_flds_count === 1) {\n\t\t\tconst sort_fld = sort_flds[0].field;\n\t\t\tconst multiplier = multipliers[0];\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\treturn multiplier * cmp(\n\t\t\t\t\tget_field(sort_fld, a),\n\t\t\t\t\tget_field(sort_fld, b)\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(a:T.ResultItem, b:T.ResultItem) {\n\t\t\t\tvar i, result, field;\n\t\t\t\tfor (i = 0; i < sort_flds_count; i++) {\n\t\t\t\t\tfield = sort_flds[i].field;\n\t\t\t\t\tresult = multipliers[i] * cmp(\n\t\t\t\t\t\tget_field(field, a),\n\t\t\t\t\t\tget_field(field, b)\n\t\t\t\t\t);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser:T.Options):T.PrepareObj {\n\t\tconst weights:T.Weights = {};\n\t\tvar options\t\t= Object.assign({},optsUser);\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tconst fields:T.Field[] = [];\n\t\t\toptions.fields.forEach((field:string|T.Field) => {\n\t\t\t\tif( typeof field == 'string' ){\n\t\t\t\t\tfield = {field:field,weight:1};\n\t\t\t\t}\n\t\t\t\tfields.push(field);\n\t\t\t\tweights[field.field] = ('weight' in field) ? field.weight : 1;\n\t\t\t});\n\t\t\toptions.fields = fields;\n\t\t}\n\n\n\t\treturn {\n\t\t\toptions\t\t: options,\n\t\t\tquery\t\t: query.toLowerCase().trim(),\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:T.Options) : T.PrepareObj {\n\t\tvar self = this, score, search:T.PrepareObj;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tconst fn_score = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (item:T.ResultItem, id:string|number) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tconst fn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n"],"names":["latin_pat","accent_pat","accent_reg","RegExp","diacritic_patterns","latin_convert","convert_pat","Object","keys","join","code_points","asciifold","str","normalize","replace","toLowerCase","foreignletter","arrayToPattern","chars","glue","length","allSubstrings","input","result","substring","forEach","subresult","tmp","slice","charAt","push","unshift","diacriticRegexPoints","regex","undefined","diacritics","code_range","i","diacritic","String","fromCharCode","latin","latin_chars","sort","a","b","pattern","map","sub_pat","l","hasOwnProperty","generateDiacritics","split","part","no_accent","composed_part","getAttr","obj","name","getAttrNesting","names","shift","scoreValue","value","token","weight","score","pos","search","string","escape_regex","propToArray","key","Array","isArray","iterate","object","callback","cmp","constructor","items","settings","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","word","field_match","field","match","this","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","n","implicit_score","self","sort_empty","sort_flds","multipliers","get_field","id","direction","splice","sort_flds_count","sort_fld","multiplier","optsUser","assign","trim","total","nesting","fn_score","item","filter","fn_sort","limit"],"mappings":"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"}