{"version":3,"file":"sifter.min.js","sources":["../../lib/diacritics.ts","../../lib/utils.ts","../../lib/sifter.ts"],"sourcesContent":["\ntype TDiacraticList = {[key:string]:string};\n\n// https://github.com/andrewrk/node-diacritics/blob/master/index.js\nvar DIACRITICS:TDiacraticList = {\n\t\" \":\" \",\n\t0:\"߀\",\n\tA:\"ⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ\",\n\tAA:\"Ꜳ\",\n\tAE:\"ÆǼǢ\",\n\tAO:\"Ꜵ\",\n\tAU:\"Ꜷ\",\n\tAV:\"ꜸꜺ\",\n\tAY:\"Ꜽ\",\n\tB:\"ⒷＢḂḄḆɃƁ\",\n\tC:\"ⒸＣꜾḈĆCĈĊČÇƇȻ\",\n\tD:\"ⒹＤḊĎḌḐḒḎĐƊƉᴅꝹ\",\n\tDh:\"Ð\",\n\tDZ:\"ǱǄ\",\n\tDz:\"ǲǅ\",\n\tE:\"ɛⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎᴇ\",\n\tF:\"ꝼⒻＦḞƑꝻ\",\n\tG:\"ⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾɢ\",\n\tH:\"ⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ\",\n\tI:\"ⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ\",\n\tJ:\"ⒿＪĴɈȷ\",\n\tK:\"ⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ\",\n\tL:\"ⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ\",\n\tLJ:\"Ǉ\",\n\tLj:\"ǈ\",\n\tM:\"ⓂＭḾṀṂⱮƜϻ\",\n\tN:\"ꞤȠⓃＮǸŃÑṄŇṆŅṊṈƝꞐᴎ\",\n\tNJ:\"Ǌ\",\n\tNj:\"ǋ\",\n\tO:\"ⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ\",\n\tOE:\"Œ\",\n\tOI:\"Ƣ\",\n\tOO:\"Ꝏ\",\n\tOU:\"Ȣ\",\n\tP:\"ⓅＰṔṖƤⱣꝐꝒꝔ\",\n\tQ:\"ⓆＱꝖꝘɊ\",\n\tR:\"ⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ\",\n\tS:\"ⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ\",\n\tT:\"ⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ\",\n\tTh:\"Þ\",\n\tTZ:\"Ꜩ\",\n\tU:\"ⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ\",\n\tV:\"ⓋＶṼṾƲꝞɅ\",\n\tVY:\"Ꝡ\",\n\tW:\"ⓌＷẀẂŴẆẄẈⱲ\",\n\tX:\"ⓍＸẊẌ\",\n\tY:\"ⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ\",\n\tZ:\"ⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ\",\n\ta:\"ⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑ\",\n\taa:\"ꜳ\",\n\tae:\"æǽǣ\",\n\tao:\"ꜵ\",\n\tau:\"ꜷ\",\n\tav:\"ꜹꜻ\",\n\tay:\"ꜽ\",\n\tb:\"ⓑｂḃḅḇƀƃɓƂ\",\n\tc:\"ｃⓒćĉċčçḉƈȼꜿↄ\",\n\td:\"ⓓｄḋďḍḑḓḏđƌɖɗƋᏧԁꞪ\",\n\tdh:\"ð\",\n\tdz:\"ǳǆ\",\n\te:\"ⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇǝ\",\n\tf:\"ⓕｆḟƒ\",\n\tff:\"ﬀ\",\n\tfi:\"ﬁ\",\n\tfl:\"ﬂ\",\n\tffi:\"ﬃ\",\n\tffl:\"ﬄ\",\n\tg:\"ⓖｇǵĝḡğġǧģǥɠꞡꝿᵹ\",\n\th:\"ⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ\",\n\thv:\"ƕ\",\n\ti:\"ⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı\",\n\tj:\"ⓙｊĵǰɉ\",\n\tk:\"ⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ\",\n\tl:\"ⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇɭ\",\n\tlj:\"ǉ\",\n\tm:\"ⓜｍḿṁṃɱɯ\",\n\tn:\"ⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥлԉ\",\n\tnj:\"ǌ\",\n\to:\"ⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿꝋꝍɵɔᴑ\",\n\toe:\"œ\",\n\toi:\"ƣ\",\n\too:\"ꝏ\",\n\tou:\"ȣ\",\n\tp:\"ⓟｐṕṗƥᵽꝑꝓꝕρ\",\n\tq:\"ⓠｑɋꝗꝙ\",\n\tr:\"ⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ\",\n\ts:\"ⓢｓśṥŝṡšṧṣṩșşȿꞩꞅẛʂ\",\n\tss:\"ß\",\n\tt:\"ⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ\",\n\tth:\"þ\",\n\ttz:\"ꜩ\",\n\tu:\"ⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ\",\n\tv:\"ⓥｖṽṿʋꝟʌ\",\n\tvy:\"ꝡ\",\n\tw:\"ⓦｗẁẃŵẇẅẘẉⱳ\",\n\tx:\"ⓧｘẋẍ\",\n\ty:\"ⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ\",\n\tz:\"ⓩｚźẑżžẓẕƶȥɀⱬꝣ\"\n}\n\n/**\n * code points generated from toCodePoints();\n * removed 65339 to 65345\n */\nvar code_points = [\n\t[ 67, 67 ],\n\t[ 160, 160 ],\n\t[ 192, 438 ],\n\t[ 452, 652 ],\n\t[ 961, 961 ],\n\t[ 1019, 1019 ],\n\t[ 1083, 1083 ],\n\t[ 1281, 1289 ],\n\t[ 1984, 1984 ],\n\t[ 5095, 5095 ],\n\t[ 7429, 7441 ],\n\t[ 7545, 7549 ],\n\t[ 7680, 7935 ],\n\t[ 8580, 8580 ],\n\t[ 9398, 9449 ],\n\t[ 11360, 11391 ],\n\t[ 42792, 42793 ],\n\t[ 42802, 42851 ],\n\t[ 42873, 42897 ],\n\t[ 42912, 42922 ],\n\t[ 64256, 64260 ],\n\t[ 65313, 65338 ],\n\t[ 65345, 65370 ]\n];\n\n/**\n * Remove accents\n * via https://github.com/krisk/Fuse/issues/133#issuecomment-318692703\n *\n */\nexport function asciifold(str:string):string{\n\treturn str.normalize('NFD').replace(/[\\u0300-\\u036F]/g, '').normalize('NFKD').toLowerCase();\n};\n\n\n/**\n * Convert list of diacritics to array of code points\n *\n */\n// @ts-ignore\nfunction toCodePoints(tolerance=8){\n\tvar char_codes = [];\n\n\tfor( let letter in DIACRITICS ){\n\t\tlet _diacritics = DIACRITICS[letter];\n\t\tfor( let n = 0; n < _diacritics.length; n++ ){\n\t\t\tvar code_point = _diacritics.codePointAt(n);\n\t\t\tchar_codes.push( code_point );\n\t\t}\n\t}\n\n\t//https://stackoverflow.com/questions/40431572/is-there-a-simple-way-to-group-js-array-values-by-range\n\tchar_codes.sort((a, b) => a - b);\n    var result = char_codes.reduce(function (accumulator, currentValue, index, source) {\n\n\t\tif( !index ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else if( currentValue - source[index - 1] > tolerance ){\n\t\t\taccumulator.push( [currentValue,currentValue] );\n\n\t\t}else{\n\n\t\t\taccumulator.push( [accumulator.pop()[0],currentValue]);\n\t\t}\n\n        return accumulator;\n    }, []);\n\n\tconsole.log(`char_codes (${result.length})`,result);\n}\n\n/**\n * Generate a list of diacritics from the list of code points\n *\n */\nexport function generateDiacritics():TDiacraticList{\n\n\tvar latin_convert = {\n\t\t'l·': 'l',\n\t\t'ʼn': 'n',\n\t\t'æ': 'ae',\n\t\t'ø': 'o',\n\t\t'aʾ': 'a',\n\t\t'dž': 'dz',\n\t};\n\n\tvar diacritics\t= {};\n\t//var no_latin\t= [];\n\tcode_points.forEach((code_range)=>{\n\n\t\tfor(let i = code_range[0]; i <= code_range[1]; i++){\n\t\t\tlet diacritic\t= String.fromCharCode(i);\n\t\t\tlet latin\t\t= diacritic.normalize('NFD').replace(/[\\u0300-\\u036F]/g, '').normalize('NFKD');\n\n\t\t\tif( latin == diacritic ){\n\t\t\t\t//no_latin.push(diacritic);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlatin = latin.toLowerCase();\n\n\t\t\tif( latin in latin_convert ){\n\t\t\t\tlatin = latin_convert[latin];\n\t\t\t}\n\n\t\t\tif( !(latin in diacritics) ){\n\t\t\t\tdiacritics[latin] = latin + latin.toUpperCase();\n\t\t\t}\n\t\t\tdiacritics[latin] += diacritic;\n\t\t}\n\t});\n\n\t//console.log('no_latin',JSON.stringify(no_latin));\n\n\treturn diacritics;\n}\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n */\nvar diacritics:TDiacraticList = null\nexport function diacriticRegexPoints(regex:string):string{\n\n\tif( diacritics === null ){\n\t\tdiacritics = generateDiacritics();\n\t}\n\n\tfor( let latin in diacritics ){\n\t\tif( diacritics.hasOwnProperty(latin) ){\n\t\t\tregex = regex.replace( new RegExp(latin,'g'), '['+diacritics[latin]+']');\n\t\t}\n\t}\n\treturn regex;\n}\n\n\n/**\n * Expand a regular expression pattern to include diacritics\n * \teg /a/ becomes /aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐɑAⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ/\n *\n * rollup will bundle this function (and the DIACRITICS constant) unless commented out\n *\nvar diacriticRegex = (function() {\n\n\tvar list = [];\n\tfor( let letter in DIACRITICS ){\n\n\t\tif( letter.toLowerCase() != letter && letter.toLowerCase() in DIACRITICS ){\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( DIACRITICS.hasOwnProperty(letter) ){\n\n\t\t\tvar replace = letter + DIACRITICS[letter];\n\t\t\tif( letter.toUpperCase() in DIACRITICS ){\n\t\t\t\treplace += letter.toUpperCase() + DIACRITICS[letter.toUpperCase()];\n\t\t\t}\n\n\t\t\tlist.push({let:letter,pat:'['+replace+']'});\n\t\t}\n\t}\n\n\treturn function(regex:string):string{\n\t\tlist.forEach((item)=>{\n\t\t\tregex = regex.replace( new RegExp(item.let,'g'),item.pat);\n\t\t});\n\t\treturn regex;\n\t}\n})();\n*/\n","\n// @ts-ignore\nimport { asciifold } from './diacritics.ts';\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport function getAttr(obj:{[key:string]:any}, name:string ) {\n    if (!obj ) return;\n    return obj[name];\n};\n\n/**\n * A property getter resolving dot-notation\n * @param  {Object}  obj     The root object to fetch property on\n * @param  {String}  name    The optionally dotted property name to fetch\n * @return {Object}          The resolved property value\n */\nexport function getAttrNesting(obj:{[key:string]:any}, name:string ) {\n    if (!obj ) return;\n    var names = name.split(\".\");\n    while(names.length && (obj = obj[names.shift()]));\n    return obj;\n};\n\n/**\n * Calculates how close of a match the\n * given value is against a search token.\n *\n * @param {object} token\n * @return {number}\n */\nexport function scoreValue(value:string, token, weight:number ) {\n\tvar score, pos;\n\n\tif (!value) return 0;\n\n\tvalue = value + '';\n\tpos = value.search(token.regex);\n\tif (pos === -1) return 0;\n\n\tscore = token.string.length / value.length;\n\tif (pos === 0) score += 0.5;\n\n\treturn score * weight;\n};\n\nexport function escape_regex(str) {\n\treturn (str + '').replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n};\n\n\n/**\n * Cast object property to an array if it exists and has a value\n *\n */\nexport function propToArray(obj, key){\n\tvar value = obj[key];\n\tif( value && !Array.isArray(value) ){\n\t\tobj[key] = [value];\n\t}\n}\n\n\n/**\n * Iterates over arrays and hashes.\n *\n * ```\n * iterate(this.items, function(item, id) {\n *    // invoked for each item\n * });\n * ```\n *\n * @param {array|object} object\n */\nexport function iterate(object, callback) {\n\n\tif ( Array.isArray(object)) {\n\t\tobject.forEach(callback);\n\n\t}else{\n\n\t\tfor (var key in object) {\n\t\t\tif (object.hasOwnProperty(key)) {\n\t\t\t\tcallback(object[key], key);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nexport function cmp(a, b) {\n\tif (typeof a === 'number' && typeof b === 'number') {\n\t\treturn a > b ? 1 : (a < b ? -1 : 0);\n\t}\n\ta = asciifold(a + '').toLowerCase();\n\tb = asciifold(b + '').toLowerCase();\n\tif (a > b) return 1;\n\tif (b > a) return -1;\n\treturn 0;\n};\n","/**\n * sifter.js\n * Copyright (c) 2013–2020 Brian Reavis & contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this\n * file except in compliance with the License. You may obtain a copy of the License at:\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n * ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n *\n * @author Brian Reavis <brian@thirdroute.com>\n */\n\n// @ts-ignore\nimport { scoreValue, getAttr, getAttrNesting, escape_regex, propToArray, iterate, cmp } from './utils.ts';\n// @ts-ignore\nimport { diacriticRegexPoints, asciifold } from './diacritics.ts';\n\n\ntype TField = {\n\tfield: string,\n\tweight?: number,\n}\n\ntype TOptions = {\n \tfields: TField[],\n \tsort: any[],\n \tscore?: ()=>any,\n \tfilter?: boolean,\n \tlimit?: number,\n \tsort_empty?: any,\n \tnesting?: boolean,\n\trespect_word_boundaries?: boolean,\n\tconjunction?: string,\n}\n\ntype TToken = {\n\tstring:string,\n\tregex:RegExp,\n\tfield:string\n}\n\ntype TWeights = {[key:string]:number}\n\ntype TPrepareObj = {\n\toptions: TOptions,\n\tquery: string,\n\ttokens: TToken[],\n\ttotal: number,\n\titems: any[],\n\tweights: TWeights,\n\tgetAttrFn: (any,string)=>any,\n\n}\n\n\nexport default class Sifter{\n\n\tpublic items: []|{};\n\tpublic settings: {diacritics:boolean};\n\n\t/**\n\t * Textually searches arrays and hashes of objects\n\t * by property (or multiple properties). Designed\n\t * specifically for autocomplete.\n\t *\n\t * @constructor\n\t * @param {array|object} items\n\t * @param {object} items\n\t */\n\tconstructor(items, settings) {\n\t\tthis.items = items;\n\t\tthis.settings = settings || {diacritics: true};\n\t};\n\n\t/**\n\t * Splits a search string into an array of individual\n\t * regexps to be used to match results.\n\t *\n\t */\n\ttokenize(query:string, respect_word_boundaries?:boolean, weights?:TWeights ):TToken[] {\n\t\tif (!query || !query.length) return [];\n\n\t\tconst tokens = [];\n\t\tconst words = query.split(/\\s+/);\n\t\tvar field_regex;\n\n\t\tif( weights ){\n\t\t\tfield_regex = new RegExp( '^('+ Object.keys(weights).map(escape_regex).join('|')+')\\:(.*)$');\n\t\t}\n\n\t\twords.forEach((word:string) => {\n\t\t\tlet field_match;\n\t\t\tlet field\t= null;\n\t\t\tlet regex\t= null;\n\n\t\t\t// look for \"field:query\" tokens\n\t\t\tif( field_regex && (field_match = word.match(field_regex)) ){\n\t\t\t\tfield\t= field_match[1];\n\t\t\t\tword\t= field_match[2];\n\t\t\t}\n\n\t\t\tif( word.length > 0 ){\n\t\t\t\tregex = escape_regex(word);\n\t\t\t\tif( this.settings.diacritics ){\n\t\t\t\t\tregex = diacriticRegexPoints(regex);\n\t\t\t\t}\n\t\t\t\tif( respect_word_boundaries ) regex = \"\\\\b\"+regex\n\t\t\t\tregex = new RegExp(regex, 'i');\n\t\t\t}\n\n\t\t\ttokens.push({\n\t\t\t\tstring : word,\n\t\t\t\tregex  : regex,\n\t\t\t\tfield  : field,\n\t\t\t});\n\t\t});\n\n\t\treturn tokens;\n\t};\n\n\n\t/**\n\t * Returns a function to be used to score individual results.\n\t *\n\t * Good matches will have a higher score than poor matches.\n\t * If an item is not a match, 0 will be returned by the function.\n\t *\n\t * @returns {function}\n\t */\n\tgetScoreFunction(query:string, options ){\n\t\tvar search = this.prepareSearch(query, options);\n\t\treturn this._getScoreFunction(search);\n\t}\n\n\t_getScoreFunction(search:TPrepareObj ){\n\t\tconst tokens\t\t= search.tokens,\n\t\ttoken_count\t\t\t= tokens.length;\n\n\t\tif (!token_count) {\n\t\t\treturn function() { return 0; };\n\t\t}\n\n\t\tconst fields\t= search.options.fields,\n\t\tweights\t\t\t= search.weights,\n\t\tfield_count\t\t= fields.length,\n\t\tgetAttrFn\t\t= search.getAttrFn;\n\n\t\tif (!field_count) {\n\t\t\treturn function() { return 1; };\n\t\t}\n\n\n\t\t/**\n\t\t * Calculates the score of an object\n\t\t * against the search query.\n\t\t *\n\t\t * @param {TToken} token\n\t\t * @param {object} data\n\t\t * @return {number}\n\t\t */\n\t\tconst scoreObject = (function() {\n\n\n\t\t\tif (field_count === 1) {\n\t\t\t\treturn function(token:TToken, data) {\n\t\t\t\t\tconst field = fields[0].field;\n\t\t\t\t\treturn scoreValue(getAttrFn(data, field), token, weights[field]);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn function(token:TToken, data) {\n\t\t\t\tvar sum = 0;\n\n\t\t\t\t// is the token specific to a field?\n\t\t\t\tif( token.field ){\n\n\t\t\t\t\tconst value = getAttrFn(data, token.field);\n\n\t\t\t\t\tif( !token.regex && value ){\n\t\t\t\t\t\tsum += (1/field_count);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += scoreValue(value, token, 1);\n\t\t\t\t\t}\n\n\n\n\t\t\t\t}else{\n\t\t\t\t\titerate(weights, (weight, field) => {\n\t\t\t\t\t\tsum += scoreValue(getAttrFn(data, field), token, weight);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn sum / field_count;\n\t\t\t};\n\t\t})();\n\n\t\tif (token_count === 1) {\n\t\t\treturn function(data) {\n\t\t\t\treturn scoreObject(tokens[0], data);\n\t\t\t};\n\t\t}\n\n\t\tif (search.options.conjunction === 'and') {\n\t\t\treturn function(data) {\n\t\t\t\tvar i = 0, score, sum = 0;\n\t\t\t\tfor (; i < token_count; i++) {\n\t\t\t\t\tscore = scoreObject(tokens[i], data);\n\t\t\t\t\tif (score <= 0) return 0;\n\t\t\t\t\tsum += score;\n\t\t\t\t}\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(data) {\n\t\t\t\tvar sum = 0;\n\t\t\t\titerate(tokens,(token:TToken)=>{\n\t\t\t\t\tsum += scoreObject(token, data);\n\t\t\t\t});\n\t\t\t\treturn sum / token_count;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Returns a function that can be used to compare two\n\t * results, for sorting purposes. If no sorting should\n\t * be performed, `null` will be returned.\n\t *\n\t * @return function(a,b)\n\t */\n\tgetSortFunction(query:string, options) {\n\t\tvar search  = this.prepareSearch(query, options);\n\t\treturn this._getSortFunction(search);\n\t}\n\n\t_getSortFunction(search:TPrepareObj){\n\t\tvar i, n, sort_fld, sort_flds_count, multiplier, implicit_score;\n\n\t\tconst self\t= this,\n\t\toptions\t\t= search.options,\n\t\tsort\t\t= (!search.query && options.sort_empty) || options.sort,\n\t\tsort_flds\t= [],\n\t\tmultipliers = [];\n\n\n\t\t/**\n\t\t * Fetches the specified sort field value\n\t\t * from a search result item.\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {object} result\n\t\t * @return {string}\n\t\t */\n\t\tconst get_field = function(name, result) {\n\t\t\tif (name === '$score') return result.score;\n\t\t\treturn search.getAttrFn(self.items[result.id], name);\n\t\t};\n\n\t\t// parse options\n\t\tif (sort) {\n\t\t\tfor (i = 0, n = sort.length; i < n; i++) {\n\t\t\t\tif (search.query || sort[i].field !== '$score') {\n\t\t\t\t\tsort_flds.push(sort[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// the \"$score\" field is implied to be the primary\n\t\t// sort field, unless it's manually specified\n\t\tif (search.query) {\n\t\t\timplicit_score = true;\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\timplicit_score = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (implicit_score) {\n\t\t\t\tsort_flds.unshift({field: '$score', direction: 'desc'});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\t\tif (sort_flds[i].field === '$score') {\n\t\t\t\t\tsort_flds.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, n = sort_flds.length; i < n; i++) {\n\t\t\tmultipliers.push(sort_flds[i].direction === 'desc' ? -1 : 1);\n\t\t}\n\n\t\t// build function\n\t\tsort_flds_count = sort_flds.length;\n\t\tif (!sort_flds_count) {\n\t\t\treturn null;\n\t\t} else if (sort_flds_count === 1) {\n\t\t\tsort_fld = sort_flds[0].field;\n\t\t\tmultiplier = multipliers[0];\n\t\t\treturn function(a, b) {\n\t\t\t\treturn multiplier * cmp(\n\t\t\t\t\tget_field(sort_fld, a),\n\t\t\t\t\tget_field(sort_fld, b)\n\t\t\t\t);\n\t\t\t};\n\t\t} else {\n\t\t\treturn function(a, b) {\n\t\t\t\tvar i, result, field;\n\t\t\t\tfor (i = 0; i < sort_flds_count; i++) {\n\t\t\t\t\tfield = sort_flds[i].field;\n\t\t\t\t\tresult = multipliers[i] * cmp(\n\t\t\t\t\t\tget_field(field, a),\n\t\t\t\t\t\tget_field(field, b)\n\t\t\t\t\t);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n\t * Parses a search query and returns an object\n\t * with tokens and fields ready to be populated\n\t * with results.\n\t *\n\t */\n\tprepareSearch(query:string, optsUser):TPrepareObj {\n\t\tconst weights\t= {};\n\t\tvar options\t\t= Object.assign({},optsUser);\n\n\t\tpropToArray(options,'sort');\n\t\tpropToArray(options,'sort_empty');\n\n\t\t// convert fields to new format\n\t\tif( options.fields ){\n\t\t\tpropToArray(options,'fields');\n\t\t\tif( Array.isArray(options.fields) && typeof options.fields[0] !== 'object' ){\n\t\t\t\tvar fields = [];\n\t\t\t\toptions.fields.forEach((fld_name) => {\n\t\t\t\t\tfields.push({field:fld_name});\n\t\t\t\t});\n\t\t\t\toptions.fields = fields;\n\t\t\t}\n\n\n\t\t\toptions.fields.forEach((field_params)=>{\n\t\t\t\tweights[field_params.field] = ('weight' in field_params) ? field_params.weight : 1;\n\t\t\t});\n\t\t}\n\n\t\tquery = asciifold( query + '' ).toLowerCase().trim();\n\n\t\treturn {\n\t\t\toptions\t\t: options,\n\t\t\tquery\t\t: query,\n\t\t\ttokens\t\t: this.tokenize(query, options.respect_word_boundaries, weights),\n\t\t\ttotal\t\t: 0,\n\t\t\titems\t\t: [],\n\t\t\tweights\t\t: weights,\n\t\t\tgetAttrFn\t: (options.nesting) ? getAttrNesting : getAttr,\n\t\t};\n\t};\n\n\t/**\n\t * Searches through all items and returns a sorted array of matches.\n\t *\n\t */\n\tsearch(query:string, options:TOptions) : TPrepareObj {\n\t\tvar self = this, score, search;\n\t\tvar fn_sort;\n\t\tvar fn_score;\n\n\t\tsearch  = this.prepareSearch(query, options);\n\t\toptions = search.options;\n\t\tquery   = search.query;\n\n\t\t// generate result scoring function\n\t\tfn_score = options.score || self._getScoreFunction(search);\n\n\t\t// perform search and sort\n\t\tif (query.length) {\n\t\t\titerate(self.items, (item, id) => {\n\t\t\t\tscore = fn_score(item);\n\t\t\t\tif (options.filter === false || score > 0) {\n\t\t\t\t\tsearch.items.push({'score': score, 'id': id});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\titerate(self.items, (item, id) => {\n\t\t\t\tsearch.items.push({'score': 1, 'id': id});\n\t\t\t});\n\t\t}\n\n\t\tfn_sort = self._getSortFunction(search);\n\t\tif (fn_sort) search.items.sort(fn_sort);\n\n\t\t// apply limits\n\t\tsearch.total = search.items.length;\n\t\tif (typeof options.limit === 'number') {\n\t\t\tsearch.items = search.items.slice(0, options.limit);\n\t\t}\n\n\t\treturn search;\n\t};\n}\n"],"names":["code_points","asciifold","str","normalize","replace","toLowerCase","diacritics","diacriticRegexPoints","regex","latin_convert","forEach","code_range","i","diacritic","String","fromCharCode","latin","toUpperCase","generateDiacritics","hasOwnProperty","RegExp","getAttr","obj","name","getAttrNesting","names","split","length","shift","scoreValue","value","token","weight","score","pos","search","string","escape_regex","propToArray","key","Array","isArray","iterate","object","callback","cmp","a","b","constructor","items","settings","tokenize","query","respect_word_boundaries","weights","tokens","words","field_regex","Object","keys","map","join","word","field_match","field","match","this","push","getScoreFunction","options","prepareSearch","_getScoreFunction","token_count","fields","field_count","getAttrFn","scoreObject","data","sum","conjunction","getSortFunction","_getSortFunction","n","sort_fld","sort_flds_count","multiplier","implicit_score","self","sort","sort_empty","sort_flds","multipliers","get_field","result","id","unshift","direction","splice","optsUser","assign","fld_name","field_params","trim","total","nesting","fn_sort","fn_score","item","filter","limit","slice"],"mappings":"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"}